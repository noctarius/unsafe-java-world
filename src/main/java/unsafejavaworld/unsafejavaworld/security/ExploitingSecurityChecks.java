package unsafejavaworld.unsafejavaworld.security;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import unsafejavaworld.unsafejavaworld.UnsafeSupport;

import java.lang.reflect.Field;
import java.util.Map;

public class ExploitingSecurityChecks {

    public static void main(String[] args) throws Exception {
        ClassWriter cw = new ClassWriter(0);

        // public final class sun.reflect.Exploit
        //            extends sun.reflect.MagicAccessorImpl
        //            implements java.util.Map
        cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL, "sun/reflect/Exploit",
                null, "sun/reflect/MagicAccessorImpl", new String[] { "java/util/Map" });

        // public Exploit() {
        //   super();
        // }
        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null);
        mv.visitCode();
        mv.visitVarInsn(Opcodes.ALOAD, 0);
        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
        mv.visitInsn(Opcodes.RETURN);
        mv.visitMaxs(1, 1);
        mv.visitEnd();

        // public java.lang.Object get(java.lang.Object) {}
        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, "get", "(Ljava/lang/Object;)Ljava/lang/Object;", null, null);
        mv.visitCode();
        mv.visitVarInsn(Opcodes.ALOAD, 0);

        // new String(char[])
        mv.visitTypeInsn(Opcodes.NEW, "java/lang/String");
        mv.visitInsn(Opcodes.DUP);

        // Build package-private String constructor call
        // Parameter 1: char[]
        mv.visitVarInsn(Opcodes.ALOAD, 1);
        mv.visitTypeInsn(Opcodes.CHECKCAST, "[C");

        // Parameter 2: true
        mv.visitInsn(Opcodes.ICONST_1);

        // Call new String(char[], boolean)
        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/String", "<init>", "([CZ)V");
        mv.visitInsn(Opcodes.ARETURN);
        mv.visitMaxs(5, 5);
        mv.visitEnd();
        cw.visitEnd();

        // Get generated bytecode
        byte[] classData = cw.toByteArray();

        // Get classloader from sun.reflect.MagicAccessorImpl
        ClassLoader classLoader = Class.forName("sun.reflect.MagicAccessorImpl").getClassLoader();

        // Use Unsafe::defineClass to load the generated class
        Class loaderClass = UnsafeSupport.UNSAFE
                .defineClass("sun/reflect/Exploit", classData, 0, classData.length, classLoader, null);

        // Instantiate our generated adapter class
        Map<char[], String> instantiationAdapter = (Map<char[], String>) loaderClass.newInstance();

        // Create char[] to pass to String constructor
        char[] data = "Test".toCharArray();

        // Create new String using our adapter
        String foo = instantiationAdapter.get(data);

        // Show content of the String instance
        System.out.println("Value of foo: " + foo);

        // Get accessor to the internal char[] field
        Field valueField = String.class.getDeclaredField("value");
        valueField.setAccessible(true);

        // Proof the shared instance
        System.out.println("char[] is shared: " + (data == valueField.get(foo)));
    }
}
